package com.biglucas.agena.utils;

import android.annotation.SuppressLint;
import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.net.Uri;
import android.util.Log;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

/**
 * Manages the application's history database.
 * <p>
 * This controller handles the SQLite database used to store browsing history.
 * It supports a dual-storage strategy:
 * <ul>
 *     <li><b>External Storage:</b> (Debug/Dev only) Used if the 'manage external storage' permission is granted.
 *         Allows the database to survive app uninstalls, facilitating development and debugging.</li>
 *     <li><b>Private Storage:</b> (Release/Default) Used in standard production builds.
 *         The database is sandboxed within the app's private directory and cleared on uninstall.</li>
 * </ul>
 * <p>
 * This class requires an open {@link SQLiteDatabase} instance to function.
 */
public class DatabaseController {
    private static final String TAG = "DatabaseController";
    private static final String TABLE_HISTORY = "history";
    private static final String COLUMN_URL = "url";
    private static final String COLUMN_ACCESSED = "accessed";

    private static final String SQL_CREATE_HISTORY_TABLE =
        "CREATE TABLE IF NOT EXISTS " + TABLE_HISTORY + " (" +
            COLUMN_URL + " TEXT, " +
            COLUMN_ACCESSED + " TIMESTAMP DEFAULT CURRENT_TIMESTAMP" +
            ");";

    private static final String SQL_INSERT_HISTORY_URL =
        "INSERT INTO " + TABLE_HISTORY + " (" + COLUMN_URL + ") VALUES (?);";

    private static final String SQL_SELECT_ALL_HISTORY_ORDERED =
        "SELECT * FROM " + TABLE_HISTORY + " ORDER BY " + COLUMN_ACCESSED + " DESC;";

    /**
     * Format string for history entries rendered as Gemini links.
     * Format: "=> [URL] [TIMESTAMP] [URL]"
     * This creates a clickable link in a Gemini page where the link text is "TIMESTAMP URL".
     */
    private static final String HISTORY_LINE_FORMAT = "=> %s %s %s";
    private static final String PRIVATE_HISTORY_FILENAME = "history";
    final SQLiteDatabase db;

    public DatabaseController(SQLiteDatabase db) {
        this.db = db;
        db.execSQL(SQL_CREATE_HISTORY_TABLE);
    }

    /**
     * Opens or creates the history database.
     * <p>
     * Delegates path resolution to {@link StorageHelper#getDatabasePath(Context)}.
     * <p>
     * <b>Flow:</b>
     * 1. Checks if external storage should be used (Developer Mode).
     * 2. Attempts to open the external database file.
     * 3. Falls back to private internal storage if external storage is unavailable,
     *    permission is denied, or an error occurs.
     *
     * @param context The application context.
     * @return An open, writable {@link SQLiteDatabase} instance.
     */
    public static SQLiteDatabase openDatabase(Context context) {
        String dbPath = StorageHelper.getDatabasePath(context);

        if (dbPath != null) {
            try {
                return SQLiteDatabase.openOrCreateDatabase(new File(dbPath), null);
            } catch (Exception e) {
                Log.e(TAG, "Failed to open external database, falling back to private storage", e);
                // Fallback to private storage if external fails for any reason
            }
        }

        // Default to private storage
        return context.openOrCreateDatabase(PRIVATE_HISTORY_FILENAME, Context.MODE_PRIVATE, null);
    }

    /**
     * Adds a visited URI to the history database.
     * <p>
     * Uses a parameterized SQL query to safely insert the URI, preventing SQL injection.
     * The timestamp is automatically generated by the database (`DEFAULT CURRENT_TIMESTAMP`).
     *
     * @param uri The URI to add to history.
     */
    public void addHistoryEntry(Uri uri) {
        Log.d(TAG, "Saving to history: " + uri.toString());
        this.db.execSQL(SQL_INSERT_HISTORY_URL, new String[]{uri.toString()});
    }

    /**
     * Retrieves the browsing history as a list of Gemini-formatted strings.
     * <p>
     * <b>Nuance:</b> This method doesn't just return raw data. It returns strings formatted
     * specifically for the {@link com.biglucas.agena.ui.GeminiPageContentFragment}.
     * <br>
     * Each string is a valid Gemtext link line: {@code => <URL> <TIMESTAMP> <URL>}
     * This allows the history list to be rendered directly as a clickable Gemini page.
     *
     * @return A list of Gemtext link lines representing the history, ordered by most recent first.
     */
    public List<String> getHistoryLines() {
        ArrayList<String> list = new ArrayList<>();
        Cursor cursor = this.db.rawQuery(SQL_SELECT_ALL_HISTORY_ORDERED, null);
        Log.d(TAG, "getHistoryLines - found " + cursor.getCount() + " entries");
        int urlColumnIndex = cursor.getColumnIndex(COLUMN_URL);
        int accessedColumnIndex = cursor.getColumnIndex(COLUMN_ACCESSED);
        while (cursor.moveToNext()) {
            String uri = cursor.getString(urlColumnIndex);
            String timestamp = cursor.getString(accessedColumnIndex);
            String toAdd = String.format(HISTORY_LINE_FORMAT, uri, timestamp, uri);
            Log.d(TAG, "History entry: " + toAdd);
            list.add(toAdd);
        }
        cursor.close();
        return list;
    }
}
